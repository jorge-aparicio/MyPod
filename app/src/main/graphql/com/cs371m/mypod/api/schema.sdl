type AccessToken {
    access_token: String!
    expires_in: Int!
    token_type: String!
}

input AccessTokenRequest {
    grant_type: OAuthGrantType!
    client_id: String!
    client_secret: String!
    code: String
    redirect_uri: String
    limited_scope: Boolean
}

type ActionResult {
    successful: Boolean!
}

union ActionResultUnion =
    ActionResult
    | NoAuthenticatedUserError
    | EntityNotFoundError
    | Error
union AddItemToListResult =
    ListItem
    | ListNotFoundError
    | IncorrectListTypeError
    | NoAuthenticatedUserError
    | Error
enum BookmarkableType {
    PODCAST
    EPISODE
}

union BookmarkResult =
    ActionResult
    | ListItemNotFoundError
    | NoAuthenticatedUserError
    | EntityNotFoundError
    | Error
type Brand {
    id: ID!
    name: String!
    code: String!
    estimatedAdSpend(from: DateTime, to: DateTime): EstimatedAdSpend
    sponsoredPodcasts(
        first: Int = 10
        page: Int
        searchTerm: String
        sort: PodcastSort
        paginationType: PaginationType
        cursor: String
    ): PodcastSponsorList
}

type BrandList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [Brand!]!
}

input BrandSort {
    sortBy: BrandSortType!
    direction: SortDirection
}

enum BrandSortType {
    ALPHABETICAL
}

union CanBeFollowed = Podcast | User | Creator | List
union CanBeRated = Podcast | Episode
type Category {
    title: String
    slug: String
}

type Character {
    name: String!
}

type ChartCategory {
    title: String
    slug: String
}

enum ChartChangeStatus {
    NO_CHANGE
    NEW
    UP
    DOWN
}

enum ChartPlatform {
    APPLE_PODCASTS
    SPOTIFY
}

type ChartPosition {
    platform: ChartPlatform!
    country: String
    day: Date!
    position: Int!
    change: Int
    changeStatus: ChartChangeStatus
    category: String
    podcastIdentifier: String
    podcast: Podcast
}

type ChartPositionPaginator {
    paginatorInfo: PaginatorInfo!
    data: [ChartPosition!]!
}

enum ChartsSortOption {
    POSITION
    CATEGORY
    COUNTRY
}

type Contact {
    email: String
    url: Url
    fullName: String
    modifiedDate: DateTime
    relation: ContactRelation
}

type ContactRelation {
    role: String
    createdAt: DateTime!
}

input CreateListInput {
    title: String!
    description: String
    privacy: ListPrivacy!
}

type Creator {
    pcid: String!
    name: String!
    informalName: String
    pronouns: Pronoun!
    subtitleShort: String
    subtitle: String
    location: String
    bio: String
    url: Url
    birthday: Date
    imageUrl: Url
    modifiedDate: DateTime
    socialLinks: CreatorSocialLinks
    followerCount: Int
    episodeAppearanceCount: Int
    credits(
        filters: CreditFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): PodcastCreditList
}

input CreatorFilters {
    followerCount: RangeInput
    modifiedDate: DateRangeInput
}

input CreatorIdentifier {
    type: CreatorIdentifierType!
    id: String!
}

enum CreatorIdentifierType {
    PCID
}

input CreatorInput {
    name: String
    informalName: String
    pronouns: Pronoun
    location: String
    biography: String
    birthday: Date
    profileImage: String
    twitter: Url
    wikipedia: Url
}

type CreatorList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [Creator!]!
}

type CreatorNotFoundError implements ErrorInterface {
    message: String!
}

type CreatorSocialLinks {
    twitter: Url
    wikipedia: Url
}

input CreatorSort {
    sortBy: CreatorSortType!
    direction: SortDirection
}

enum CreatorSortType {
    FOLLOWER_COUNT
    ALPHABETICAL
    RELEVANCE
    TRENDING
    RECENT_EPISODE
    APPEARANCE_COUNT
}

union Creditable = Podcast | Episode
input CreditFilters {
    role: [String]
    modifiedDate: DateRangeInput
}

type CreditSubmission {
    id: ID
    creator: Creator!
    podcast: Podcast!
    role: Role!
    operationType: CreditSubmissionOperation
    characterName: String
    state: CreditSubmissionState
    episodes(
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): EpisodeList
}

type CreditSubmissionAlreadySubmittedError implements ErrorInterface {
    message: String!
}

enum CreditSubmissionOperation {
    addEpisodeCredits
    removeEpisodeCredits
    removeCharacterFromEpisodeCredits
}

enum CreditSubmissionState {
    submitted
    approved
    committed
}

type CursorInfo {
    total: Int!
    nextCursor: String
    cursorRefreshed: Boolean
}

scalar Date

input DateRangeInput {
    from: DateTime
    to: DateTime
}

scalar DateTime

scalar DateTimeTz

union DeleteListResult =
    ActionResult
    | ListNotFoundError
    | NoAuthenticatedUserError
    | Error
type DemographicRange {
    to: String
    from: String
    count: Float
}

type DemographicSegment {
    title: String
    percentage: Float
}

type DuplicateCreatorNameError implements ErrorInterface {
    message: String!
    existingCreator: Creator!
}

union EditCreatorResult =
    Creator
    | DuplicateCreatorNameError
    | UnauthorizedCreatorEditError
    | NoAuthenticatedUserError
    | ValidationError
    | Error
union EditListResult = List | ListNotFoundError | Error
type EmailContact {
    email: String
    name: String
}

type EntityNotFoundError implements ErrorInterface {
    message: String!
    entityId: Int
    entityType: String
}

input EntityToRate {
    entityId: ID!
    entityType: RateableType
}

input EntityToReview {
    entityId: Int!
    entityType: ReviewableType
}

type Episode {
    id: ID!
    title: String!
    description: String
    htmlDescription: String
    airDate: DateTime!
    imageUrl: Url
    audioUrl: Url
    url: Url
    fileSize: Int
    guid: String
    length: Int
    explicit: Boolean!
    episodeType: String!
    modifiedDate: DateTime
    podcast: Podcast!
    ratingCount: Int
    reviewCount: Int
    userRating: Rating
    userReview: Review
    ratingAverage: Float
    ratingSummary: [RatingSummary]
    transcripts: [Transcript]
    estimatedReach: Int @deprecated(reason: "use 'audienceReach'")
    audienceReach: IntegerRange
    ratings(
        filters: RatingFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: RatingSort
        paginationType: PaginationType
        cursor: String
    ): RatingList
    reviews(
        filters: ReviewFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: ReviewSort
        paginationType: PaginationType
        cursor: String
    ): ReviewList
    credits(
        filters: CreditFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): EpisodeCreditList
    lists(
        filters: ListFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: ListSort
        paginationType: PaginationType
        cursor: String
    ): ListList
    sponsors(
        first: Int = 10
        page: Int
    ): EpisodeSponsorPaginator
}

type EpisodeCredit {
    id: ID
    episode: Episode
    creator: Creator!
    role: Role!
    podcastCredit: PodcastCredit!
    characters: [Character]
    modifiedDate: DateTime
}

type EpisodeCreditList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [EpisodeCredit!]!
}

input EpisodeFilters {
    airDate: [DateRangeInput]
    length: [RangeInput]
    modifiedDate: DateRangeInput
    podcastPowerScore: [RangeInput]
    isExplicit: [Boolean]
    sponsoredBy: [String]
    episodeType: [EpisodeType]
}

input EpisodeIdentifier {
    id: String!
    type: EpisodeIdentifierType!
    podcast: PodcastIdentifier
}

enum EpisodeIdentifierType {
    GUID
    PODCHASER
}

type EpisodeList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [Episode!]!
}

input EpisodeSelection {
    selectionType: EpisodeSelectionType
    episodes: [EpisodeIdentifier!]
    dateRange: DateRangeInput
}

enum EpisodeSelectionType {
    SPECIFIC_EPISODES
    ALL_EPISODES
    DATE_RANGE
}

input EpisodeSort {
    sortBy: EpisodeSortType!
    direction: SortDirection
}

enum EpisodeSortType {
    ALPHABETICAL
    RELEVANCE
    TRENDING
    AIR_DATE
    FOLLOWER_COUNT
}

type EpisodeSponsor {
    id: ID!
    brand: Brand
    episode: Episode
}

type EpisodeSponsorPaginator {
    paginatorInfo: PaginatorInfo!
    data: [EpisodeSponsor!]!
}

enum EpisodeType {
    FULL
    TRAILER
    BONUS
}

type Error implements ErrorInterface {
    message: String!
}

interface ErrorInterface {
    message: String!
}

type EstimatedAdSpend {
    low: Float
    high: Float
}

type Feed {
    id: ID!
    podcast: Podcast
    episodes: [Episode!]
    source: String!
    addedFrom: String
    resourceIdentifier: String!
    isPrimary: Boolean
    podcastData: PodcastFeedData
}

type FeedApproval {
    id: ID!
    url: String!
    user: User
    createdAt: DateTime
}

type Follow {
    entity: CanBeFollowed
    user: User
    followedAt: DateTime
}

enum Followable {
    PODCAST
    CREATOR
    USER
    LIST
}

type FollowPaginator {
    paginatorInfo: PaginatorInfo!
    data: [Follow!]!
}

type FollowResult {
    status: FollowResultStatus!
    subscribed: Boolean!
}

enum FollowResultStatus {
    FOLLOWED
    UNFOLLOWED
    UNSUBSCRIBED
    FOLLOW_REQUESTED
    FOLLOW_REQUEST_CANCELLED
}

union FollowResultUnion =
    FollowResult
    | NoExistingFollowError
    | NoAuthenticatedUserError
    | Error
interface HasFollowers {
    followers: [Follow]
}

type IncorrectListTypeError implements ErrorInterface {
    message: String!
}

type IntegerRange {
    from: Int
    to: Int
}

type InvalidEpisodeSelectionError implements ErrorInterface {
    message: String!
}

type InvalidRoleCodeError implements ErrorInterface {
    message: String!
}

type List {
    id: ID!
    title: String!
    description: String
    privacy: ListPrivacy!
    url: Url
    followerCount: Int
    likeCount: Int
    updatedAt: DateTime
    createdAt: DateTime
    owners(
        first: Int = 10
        page: Int
    ): UserPaginator
    items(
        first: Int = 10
        page: Int
    ): ListItemPaginator
}

union Listable = Podcast | Episode | ListHeading
type Listen {
    episode: Episode!
    user: User!
    listenDate: DateTime
}

input ListenFilters {
    listenDate: DateRangeInput
}

type ListenList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [Listen!]!
}

input ListenSort {
    sortBy: ListenSortType!
    direction: SortDirection
}

enum ListenSortType {
    LISTEN_DATE
}

input ListFilters {
    itemCount: RangeInput
    updatedAt: DateRangeInput
    listType: ListType
    followerCount: RangeInput
    likeCount: RangeInput
}

type ListHeading {
    heading: String
}

input ListIdentifier {
    id: ID!
    type: ListIdentifierType
}

enum ListIdentifierType {
    PODCHASER
    ENCODED
    LINK_ONLY
}

type ListItem {
    id: ID!
    item: Listable
    note: ListNote
    position: Int!
}

type ListItemNotFoundError implements ErrorInterface {
    message: String!
}

type ListItemNotInListError implements ErrorInterface {
    message: String!
}

type ListItemPaginator {
    paginatorInfo: PaginatorInfo!
    data: [ListItem!]!
}

input ListItemPosition {
    listItemId: ID!
    position: Int!
}

type ListList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [List!]!
}

type ListNote {
    noteText: String!
    user: User
}

union ListNoteEditResult =
    ListItem
    | ListNotFoundError
    | ListItemNotFoundError
    | ListItemNotInListError
    | NoteAlreadyExistsError
    | NoNoteOnListItemError
    | NoAuthenticatedUserError
    | Error
type ListNotFoundError implements ErrorInterface {
    message: String!
}

enum ListPrivacy {
    PRIVATE
    LINK_ONLY
    PUBLIC
}

input ListSort {
    sortBy: ListSortType!
    direction: SortDirection
}

enum ListSortType {
    ALPHABETICAL
    LIKE_COUNT
    FOLLOWER_COUNT
    UPDATE_DATE
}

enum ListType {
    PODCAST
    EPISODE
}

type Mention {
    startTime: String
    endTime: String
    snippet: String
}

union Moderatable = Podcast | Feed | FeedApproval
enum ModerationReason {
    NEW_FEED
    POSSIBLE_DUPLICATE
    POSSIBLE_DUPLICATE_PODCAST
    CREDIT_SUBMISSION
    CREATOR_SUBMISSION
}

type ModerationReasonStats {
    reason: ModerationReason!
    taskCount: Int!
}

type ModerationStats {
    taskCount: Int!
    reasonStats: [ModerationReasonStats]!
}

type ModerationTask {
    id: ID!
    toModerate: Moderatable
    relatedModels: [Moderatable]!
    reason: ModerationReason!
    resolvedBy: User
    resolvedAt: DateTime
}

input ModerationTaskFilters {
    reason: [ModerationReason]
    onlyUserSubmitted: Boolean
    resolved: Boolean
}

type ModerationTaskList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [ModerationTask!]!
}

type Mutation {
    addCreditToEpisodes(
        creator: CreatorIdentifier!
        podcast: PodcastIdentifier!
        roleCode: String!
        episodeSelection: EpisodeSelection!
        characterName: String
    ): SubmitCreditResult
    removeCreditFromEpisodes(
        creator: CreatorIdentifier!
        podcast: PodcastIdentifier!
        roleCode: String!
        episodeSelection: EpisodeSelection!
    ): SubmitCreditResult
    removeCharacterFromEpisodes(
        creator: CreatorIdentifier!
        podcast: PodcastIdentifier!
        roleCode: String!
        episodeSelection: EpisodeSelection!
        characterName: String
    ): SubmitCreditResult
    addRecurringCredit(
        creator: CreatorIdentifier!
        podcast: PodcastIdentifier!
        roleCode: String!
        characterName: String
    ): SubmitCreditResult
    removeRecurringCredit(
        creator: CreatorIdentifier!
        podcast: PodcastIdentifier!
        roleCode: String!
        characterName: String
    ): SubmitCreditResult
    submitPodcast(identifier: String!): SubmitPodcastResponse
    requestAccessToken(input: AccessTokenRequest!): AccessToken
    addBookmark(entityId: ID!, entityType: BookmarkableType!): BookmarkResult
    removeBookmark(entityId: ID!, entityType: BookmarkableType!): BookmarkResult
    createList(data: CreateListInput!): EditListResult
    updateList(identifier: ListIdentifier!, data: UpdateListInput): EditListResult
    addItemToList(
        identifier: ListIdentifier!
        entityId: ID!
        entityType: ListType!
        position: Int
    ): AddItemToListResult
    removeItemFromList(
        identifier: ListIdentifier!
        entityId: ID!
        entityType: ListType!
    ): RemoveItemFromListResult
    addHeadingToList(
        identifier: ListIdentifier!
        headingText: String!
        position: Int
    ): AddItemToListResult
    removeHeadingFromList(
        identifier: ListIdentifier!
        listItemId: ID!
    ): RemoveItemFromListResult
    reorderList(
        identifier: ListIdentifier!
        newItemOrder: [ListItemPosition]
    ): ReorderListResult
    deleteList(identifier: ListIdentifier!): DeleteListResult
    addNoteToListItem(
        identifier: ListIdentifier!
        listItemId: ID!
        noteText: String!
    ): ListNoteEditResult
    removeNoteFromListItem(
        identifier: ListIdentifier!
        listItemId: ID!
    ): ListNoteEditResult
    markEpisodeListened(episodeId: ID!): ActionResultUnion
    markEpisodeNotListened(episodeId: ID!): ActionResultUnion
    addRating(entity: EntityToRate!, rating: Int!): RatingResult!
    updateRating(entity: EntityToRate!, rating: Int!): RatingResult!
    deleteRating(entity: EntityToRate!): ActionResultUnion
    addReview(entity: EntityToReview!, content: String): ReviewResult!
    updateReview(entity: EntityToReview!, content: String): ReviewResult!
    deleteReview(entity: EntityToReview!): ActionResultUnion
    followEntity(
        entityId: Int!
        entityType: Followable!
        subscribe: Boolean = false
    ): FollowResultUnion!
    unsubscribeFromEntity(
        entityId: Int!
        entityType: Followable!
    ): FollowResultUnion
    unfollowEntity(entityId: Int!, entityType: Followable!): FollowResultUnion
    approveFeed(id: ID!): ModerationTask!
    rejectFeed(id: ID!, reason: String!): ModerationTask!
    markFeedAsDuplicate(
        id: ID!
        podcastId: ID!
        makePrimary: Boolean!
    ): ModerationTask!
}

type NoAuthenticatedUserError implements ErrorInterface {
    message: String!
}

type NoExistingFollowError implements ErrorInterface {
    message: String!
}

type NoNoteOnListItemError implements ErrorInterface {
    message: String!
}

type NoteAlreadyExistsError implements ErrorInterface {
    message: String!
}

enum OAuthGrantType {
    CLIENT_CREDENTIALS
    AUTHORIZATION_CODE
}

input OrderByClause {
    column: String!
    order: SortOrder!
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
    total: Int!
    count: Int!
    currentPage: Int!
    lastPage: Int!
}

enum PaginationType {
    PAGE
    CURSOR
}

type PaginatorInfo {
    count: Int!
    currentPage: Int!
    firstItem: Int
    hasMorePages: Boolean!
    lastItem: Int
    lastPage: Int!
    perPage: Int!
    total: Int!
}

type Podcast {
    id: ID!
    title: String!
    description: String
    sanitizedDescription: String @deprecated(reason: "use 'htmlDescription'")
    htmlDescription: String
    url: Url
    webUrl: Url
    rssUrl: String
    imageUrl: Url
    language: String
    modifiedDate: DateTime
    numberOfEpisodes: Int
    avgEpisodeLength: Int
    daysBetweenEpisodes: Int
    startDate: DateTime
    latestEpisodeDate: DateTime
    socialLinks: PodcastSocialLinks
    categories: [Category]
    hasGuests: Boolean
    feeds: [Feed!]
    userRating: Rating
    userReview: Review
    ratingCount: Int
    ratingAverage: Float
    ratingSummary: [RatingSummary]
    reviewCount: Int
    applePodcastsId: String
    itunesID: String @deprecated(reason: "use 'applePodcastsId'")
    author: EmailContact
    itunesAuthor: EmailContact @deprecated(reason: "use 'author'")
    powerScore: Float
    audienceEstimate: Float
    episodeAudienceEstimate: IntegerRange
    contacts: [Contact]
    demographics: PodcastDemographics
    removedInfo: PodcastRemovedInfo
    episodes(
        filters: EpisodeFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: EpisodeSort
        paginationType: PaginationType
        cursor: String
    ): EpisodeList
    credits(
        filters: CreditFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): PodcastCreditList
    lists(
        filters: ListFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: ListSort
        paginationType: PaginationType
        cursor: String
    ): ListList
    ratings(
        filters: RatingFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: RatingSort
        paginationType: PaginationType
        cursor: String
    ): RatingList
    reviews(
        filters: ReviewFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: ReviewSort
        paginationType: PaginationType
        cursor: String
    ): ReviewList
    similarPodcasts(
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): PodcastList
    charts(
        platform: ChartPlatform!
        day: Date!
        category: String
        country: String
        sort: [PodcastChartsSortOrderByClause!]
        first: Int = 10
        page: Int
    ): ChartPositionPaginator
    sponsors(
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): PodcastSponsorList
}

input PodcastChartsSortOrderByClause {
    column: ChartsSortOption!
    order: SortOrder!
}

type PodcastCredit {
    id: ID
    podcast: Podcast!
    creator: Creator!
    role: Role!
    modifiedDate: DateTime
    episodeCount: Int!
    episodeCredits(
        filters: CreditFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): EpisodeCreditList
}

input PodcastCreditIdentifier {
    id: String!
    type: PodcastCreditIdentifierType!
}

enum PodcastCreditIdentifierType {
    PODCHASER
}

type PodcastCreditList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [PodcastCredit!]!
}

type PodcastDemographics {
    medianAge: Float
    ageRanges: [DemographicRange]
    medianIncome: Float
    incomeRanges: [DemographicRange]
    genderBias: DemographicSegment
    countries: [DemographicSegment]
    cities: [DemographicSegment]
    occupations: [DemographicSegment]
    interests: [DemographicSegment]
    brands: [DemographicSegment]
    influencers: [DemographicSegment]
    employers: [DemographicSegment]
    ethnicities: [DemographicSegment]
}

type PodcastFeedData {
    title: String
    description: String
    artworkUrl: Url
    website: Url
    languageCode: String
    isExplicit: Boolean
    episodes: [PodcastFeedEpisode]
    error: String
}

type PodcastFeedEpisode {
    title: String
    airDate: Date!
    audioUrl: Url
}

input PodcastFilters {
    country: String
    language: String
    rating: RatingFilter
    categories: [String]
    modifiedDate: DateRangeInput
    powerScore: [RangeInput]
    identifiers: [PodcastIdentifier]
    dateOfLatestEpisode: DateRangeInput
    hasGuests: [Boolean]
    includeRemoved: Boolean
    episodeAudienceEstimate: RangeInput
}

input PodcastIdentifier {
    id: String!
    type: PodcastIdentifierType!
}

enum PodcastIdentifierType {
    APPLE_PODCASTS
    SPOTIFY
    RSS
    PODCHASER
}

type PodcastList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [Podcast!]!
}

type PodcastNotFoundError implements ErrorInterface {
    message: String!
}

enum PodcastRemovalReason {
    UNKNOWN
    REDIRECTED
    REQUESTED_BY_OWNER
    INAPPROPRIATE_CONTENT
    SPAM
}

type PodcastRemovedInfo {
    isRemoved: Boolean!
    reason: PodcastRemovalReason
    removedDate: DateTime
    redirectedPodcast: Podcast
}

type PodcastSocialLinks {
    twitter: Url
    facebook: Url
    instagram: Url
}

input PodcastSort {
    sortBy: PodcastSortType!
    direction: SortDirection
}

enum PodcastSortType {
    ALPHABETICAL
    RELEVANCE
    TRENDING
    DATE_OF_FIRST_EPISODE
    FOLLOWER_COUNT
    POWER_SCORE
}

type PodcastSponsor {
    podcast: Podcast!
    brand: Brand!
    episode_count: Int!
}

type PodcastSponsorList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [PodcastSponsor!]!
}

type ProfileUser {
    id: ID!
    profileImageUrl: Url
    email: String!
    username: String!
    displayName: String
    informalName: String
    top8: List
    bookmarks(type: BookmarkableType): List
    lists(
        filters: ListFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: ListSort
        paginationType: PaginationType
        cursor: String
    ): ListList
    ratings(
        filters: RatingFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): RatingList
    reviews(
        filters: ReviewFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): ReviewList
    following(
        entityType: Followable
        first: Int = 10
        page: Int
    ): FollowPaginator
    listens(
        filters: ListenFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: ListenSort
        paginationType: PaginationType
        cursor: String
    ): ListenList
}

enum Pronoun {
    THEY_THEM
    SHE_HER
    HE_HIM
    UNSURE
}

type Query {
    apiVersion: String!
    brand(code: String!): Brand
    podcastCredit(identifier: PodcastCreditIdentifier!): PodcastCredit
    creator(identifier: CreatorIdentifier!): Creator
    podcast(identifier: PodcastIdentifier!): Podcast
    episode(identifier: EpisodeIdentifier!): Episode
    list(identifier: ListIdentifier!): List
    user(username: String!): User
    profile: ProfileUser
    feed(id: ID!): Feed
    chartCategories(platform: ChartPlatform!): [ChartCategory!]!
    transcriptSearch(
        filters: TranscriptFilters
        term: String!
        first: Int
        page: Int
    ): TranscriptSearchResults!
    brands(
        first: Int = 10
        page: Int
        searchTerm: String
        sort: BrandSort
        paginationType: PaginationType
        cursor: String
    ): BrandList
    credits(
        filters: CreditFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): PodcastCreditList
    creators(
        filters: CreatorFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: CreatorSort
        paginationType: PaginationType
        cursor: String
    ): CreatorList
    podcasts(
        filters: PodcastFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: PodcastSort
        paginationType: PaginationType
        cursor: String
    ): PodcastList
    charts(
        platform: ChartPlatform!
        day: Date!
        category: String
        country: String
        sort: [QueryChartsSortOrderByClause!]
        first: Int = 10
        page: Int
    ): ChartPositionPaginator
    episodes(
        filters: EpisodeFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: EpisodeSort
        paginationType: PaginationType
        cursor: String
    ): EpisodeList
    lists(
        filters: ListFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: ListSort
        paginationType: PaginationType
        cursor: String
    ): ListList
    users(
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): UserList
    moderationTasks(
        filters: ModerationTaskFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): ModerationTaskList
    ratings(
        filters: RatingFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: RatingSort
        paginationType: PaginationType
        cursor: String
    ): RatingList
    reviews(
        filters: ReviewFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: Sort
        paginationType: PaginationType
        cursor: String
    ): ReviewList
}

input QueryChartsSortOrderByClause {
    column: ChartsSortOption!
    order: SortOrder!
}

input RangeInput {
    from: Int
    to: Int
}

enum RateableType {
    PODCAST
    EPISODE
}

type Rating {
    id: ID!
    user: User!
    ratedEntity: CanBeRated!
    rating: Int!
    ratedAt: DateTime!
    modifiedDate: DateTime
}

input RatingFilter {
    minRating: Float
    maxRating: Float
}

input RatingFilters {
    rating: RangeInput
    ratedDate: DateRangeInput
    modifiedDate: DateRangeInput
}

type RatingList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [Rating!]!
}

union RatingResult =
    Rating
    | NoAuthenticatedUserError
    | EntityNotFoundError
    | Error
input RatingSort {
    sortBy: RatingSortType!
    direction: SortDirection
}

enum RatingSortType {
    RATING
    RATED_DATE
}

type RatingSummary {
    value: Int
    count: Int
}

type RecurringCreditSubmission {
    id: ID
    creator: Creator!
    podcast: Podcast!
    role: Role!
    characterName: String
    isRecurring: Boolean!
    state: CreditSubmissionState
}

type RedundantCreditSubmissionError implements ErrorInterface {
    message: String!
}

union RemoveItemFromListResult =
    ActionResult
    | ListItemNotFoundError
    | ListNotFoundError
    | NoAuthenticatedUserError
    | Error
union ReorderListResult =
    List
    | ListNotFoundError
    | ListItemNotFoundError
    | ListItemNotInListError
    | NoAuthenticatedUserError
    | Error
type Review {
    id: ID!
    user: User!
    rating: Rating
    reviewedEntity: Reviewable!
    reviewable: Reviewable! @deprecated(reason: "use 'reviewedEntity'")
    content: String!
    url: Url
    reviewedAt: DateTime!
    modifiedDate: DateTime
    reply: ReviewReply
}

union Reviewable = Podcast | Episode
enum ReviewableType {
    PODCAST
    EPISODE
}

input ReviewFilters {
    reviewDate: DateRangeInput
    modifiedDate: DateRangeInput
}

type ReviewList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [Review!]!
}

union ReviewReplier = Podcast | Creator
type ReviewReply {
    content: String!
    repliedAt: DateTime!
    replier: ReviewReplier!
    review: Review!
}

union ReviewResult =
    Review
    | NoAuthenticatedUserError
    | EntityNotFoundError
    | Error
input ReviewSort {
    sortBy: ReviewSortType!
    direction: SortDirection
}

enum ReviewSortType {
    REVIEW_DATE
}

type Role {
    code: String!
    title: String!
    description: String!
}

type SimplePaginatorInfo {
    count: Int!
    currentPage: Int!
    firstItem: Int
    lastItem: Int
    perPage: Int!
}

input Sort {
    sortBy: SortType!
    direction: SortDirection
}

enum SortDirection {
    ASCENDING
    DESCENDING
}

enum SortOrder {
    ASC
    DESC
}

enum SortType {
    RELEVANCE
    DATE
}

union SubmitCreditResult =
    CreditSubmission
    | InvalidEpisodeSelectionError
    | RecurringCreditSubmission
    | PodcastNotFoundError
    | CreatorNotFoundError
    | CreditSubmissionAlreadySubmittedError
    | RedundantCreditSubmissionError
    | InvalidRoleCodeError
    | NoAuthenticatedUserError
    | Error
type SubmitPodcastResponse {
    submitted: Boolean
    status: String
    podcast: Podcast
}

type Transcript {
    url: Url!
    source: String!
    generatedDate: DateTime
}

input TranscriptFilters {
    identifiers: [PodcastIdentifier]
    powerScore: [RangeInput]
    airDate: [DateRangeInput]
    categories: [String]
}

type TranscriptPaginatorInfo {
    count: Int!
    currentPage: Int!
    firstItem: Int
    hasMorePages: Boolean!
    lastItem: Int
    lastPage: Int
    perPage: Int!
    total: Int!
}

type TranscriptSearchData {
    mentionCount: Int
    episode: Episode
    mentions: [Mention]
}

type TranscriptSearchResults {
    data: [TranscriptSearchData]
    paginatorInfo: TranscriptPaginatorInfo
}

enum Trashed {
    ONLY
    WITH
    WITHOUT
}

type UnauthorizedCreatorEditError implements ErrorInterface {
    message: String!
}

input UpdateListInput {
    title: String
    description: String
    privacy: ListPrivacy
}

input UpdateUserInput {
    username: String!
    email: String!
    bio: String
}

scalar Url

type User {
    id: ID!
    username: String!
    displayName: String
    informalName: String
    url: Url
    top8: List
    profileImageUrl: Url
    lists(
        filters: ListFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: ListSort
        paginationType: PaginationType
        cursor: String
    ): ListList
    ratings(
        filters: RatingFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: RatingSort
        paginationType: PaginationType
        cursor: String
    ): RatingList
    reviews(
        filters: ReviewFilters
        first: Int = 10
        page: Int
        searchTerm: String
        sort: ReviewSort
        paginationType: PaginationType
        cursor: String
    ): ReviewList
    following(
        entityType: Followable
        first: Int = 10
        page: Int
    ): FollowPaginator
}

type UserList {
    paginatorInfo: PaginatorInfo
    cursorInfo: CursorInfo
    data: [User!]!
}

type UserPaginator {
    paginatorInfo: PaginatorInfo!
    data: [User!]!
}

type ValidationError implements ErrorInterface {
    message: String!
    validationErrors: [ValidationMessage]!
}

type ValidationMessage {
    field: String!
    message: String!
}

